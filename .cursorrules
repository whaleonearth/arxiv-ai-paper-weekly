# Cursor Rules for ArXiv Weekly Popular

## Core Principles
1. **No Emojis**: Never use emojis in code, comments, documentation, or outputs
2. **Clean & Testable**: Write simple, clear code that's easy to test
3. **Beginner-Friendly**: Code should be readable by non-technical users

## Code Style & Structure

### General Guidelines
- Use descriptive variable and function names
- Keep functions small and focused (max 20-30 lines)
- Use type hints for all function parameters and return values
- Add docstrings to all functions and classes
- Prefer composition over inheritance
- Use early returns to reduce nesting

### Naming Conventions
```python
# Good examples
def fetch_trending_papers() -> List[Paper]:
def calculate_engagement_score(paper: Paper) -> float
class PaperRecommender:
user_interests: List[str]

# Avoid abbreviations
# Bad: calc_score, usr_prefs, rec_sys
# Good: calculate_score, user_preferences, recommendation_system
```

### Function Design
- Each function should do ONE thing only
- Functions should be pure when possible (no side effects)
- Always validate input parameters
- Return meaningful data structures, not tuples

```python
# Good
def validate_paper_data(paper: Dict) -> bool:
    """Check if paper data contains required fields."""
    required_fields = ['title', 'abstract', 'authors']
    return all(field in paper for field in required_fields)

# Bad
def process_paper(paper):
    # Validates, processes, and saves paper (too many responsibilities)
    pass
```

## Testing Requirements

### Test Structure
- Every module must have corresponding test file (test_module_name.py)
- Use pytest framework
- Write tests BEFORE implementing features (TDD approach)
- Aim for 80%+ code coverage

### Test Organization
```python
# test_paper_processor.py
import pytest
from paper_processor import PaperProcessor

class TestPaperProcessor:
    def setup_method(self):
        """Setup test data before each test."""
        self.processor = PaperProcessor()
        self.sample_paper = {
            'title': 'Sample Paper',
            'abstract': 'Sample abstract',
            'authors': ['Author 1']
        }
    
    def test_process_valid_paper(self):
        """Test processing a valid paper."""
        result = self.processor.process(self.sample_paper)
        assert result.is_valid
        assert result.title == 'Sample Paper'
    
    def test_process_invalid_paper(self):
        """Test handling of invalid paper data."""
        invalid_paper = {'title': 'No abstract'}
        with pytest.raises(ValueError):
            self.processor.process(invalid_paper)
```

### Testable Code Patterns
- Use dependency injection
- Separate business logic from I/O operations
- Mock external API calls
- Create factory functions for test data

## Documentation Standards

### Code Documentation
- Every public function needs a docstring
- Use Google-style docstrings
- Include examples in docstrings for complex functions
- Document error conditions and edge cases

```python
def calculate_trending_score(
    github_stars: int,
    citation_count: int,
    days_since_publication: int
) -> float:
    """Calculate trending score for a research paper.
    
    Args:
        github_stars: Number of GitHub stars for related code
        citation_count: Number of citations the paper has received
        days_since_publication: Days since paper was published
        
    Returns:
        Float score between 0.0 and 10.0, higher means more trending
        
    Raises:
        ValueError: If any input is negative
        
    Example:
        >>> score = calculate_trending_score(100, 50, 7)
        >>> print(f"Score: {score:.2f}")
        Score: 7.85
    """
    if github_stars < 0 or citation_count < 0 or days_since_publication < 0:
        raise ValueError("All inputs must be non-negative")
    
    # Implementation here
    return score
```

### README and Setup Documentation
- Step-by-step setup instructions
- Clear explanation of what the project does
- Examples of configuration
- Troubleshooting section
- No technical jargon without explanation

## Error Handling

### Graceful Error Handling
- Use specific exception types
- Provide helpful error messages
- Log errors with context
- Never use bare except clauses

```python
# Good
try:
    paper_data = fetch_paper_from_api(paper_id)
except requests.HTTPError as e:
    logger.error(f"Failed to fetch paper {paper_id}: {e}")
    return None
except requests.Timeout:
    logger.warning(f"Timeout fetching paper {paper_id}, retrying...")
    return retry_fetch_paper(paper_id)

# Bad
try:
    paper_data = fetch_paper_from_api(paper_id)
except:
    return None
```

### Input Validation
- Validate all user inputs
- Provide clear validation error messages
- Use type checking at runtime for critical functions

## Configuration Management

### Environment Variables
- Use clear, descriptive names
- Provide default values when sensible
- Document all environment variables
- Group related settings

```python
# config.py
import os
from dataclasses import dataclass
from typing import Optional

@dataclass
class EmailConfig:
    """Email configuration settings."""
    smtp_server: str
    smtp_port: int
    sender_email: str
    sender_password: str
    
    @classmethod
    def from_env(cls) -> 'EmailConfig':
        """Load email config from environment variables."""
        return cls(
            smtp_server=os.getenv('SMTP_SERVER', 'localhost'),
            smtp_port=int(os.getenv('SMTP_PORT', '587')),
            sender_email=os.getenv('SENDER_EMAIL', ''),
            sender_password=os.getenv('SENDER_PASSWORD', '')
        )
```

## Project Structure

### Organized Directory Layout
```
project/
├── src/                    # Main source code
│   ├── core/              # Core business logic
│   ├── data/              # Data processing modules
│   ├── integrations/      # External API integrations
│   └── utils/             # Utility functions
├── tests/                 # All test files
├── config/               # Configuration files
├── docs/                 # Documentation
├── scripts/              # Utility scripts
└── examples/             # Usage examples
```

### Module Organization
- Each module should have a clear, single responsibility
- Use __init__.py files to create clean public APIs
- Separate data models from business logic
- Keep external dependencies isolated

## GitHub Actions Friendly

### Non-Technical User Considerations
- Provide template configuration files
- Use GitHub repository variables for easy setup
- Clear error messages in workflow logs
- Automated testing and validation
- One-click deployment options

### Workflow Design
- Fail fast with clear error messages
- Provide progress indicators
- Save artifacts for debugging
- Use semantic versioning for releases

## Performance Guidelines

### Efficient Code Patterns
- Use generators for large datasets
- Implement caching for expensive operations
- Batch API calls when possible
- Use connection pooling for HTTP requests

```python
# Good - generator for memory efficiency
def process_papers_in_batches(papers: List[Paper], batch_size: int = 10):
    """Process papers in batches to manage memory usage."""
    for i in range(0, len(papers), batch_size):
        batch = papers[i:i + batch_size]
        yield process_batch(batch)

# Good - caching expensive operations
from functools import lru_cache

@lru_cache(maxsize=128)
def get_paper_embeddings(abstract: str) -> List[float]:
    """Get embeddings for paper abstract (cached)."""
    return embedding_model.encode(abstract)
```

## Security Considerations

### Safe Practices
- Never commit API keys or passwords
- Validate and sanitize all inputs
- Use environment variables for secrets
- Implement rate limiting for API calls
- Log security-relevant events

## Code Review Checklist

Before submitting code, ensure:
- [ ] No emojis anywhere in code or comments
- [ ] All functions have type hints and docstrings
- [ ] Tests are written and passing
- [ ] Code is self-documenting with clear variable names
- [ ] Error handling is comprehensive
- [ ] Configuration is externalized
- [ ] Performance is considered
- [ ] Security best practices followed
- [ ] Documentation is updated

## Examples for Non-Technical Users

### Simple Configuration Example
```yaml
# config/user_interests.yml
# Edit this file to customize your research interests

research_areas:
  - machine learning      # Papers about ML algorithms and techniques
  - computer vision       # Image and video processing research
  - natural language      # Text processing and language models

categories:
  - cs.AI                 # Artificial Intelligence papers
  - cs.LG                 # Machine Learning papers
  - cs.CV                 # Computer Vision papers

keywords:
  - neural networks       # Papers mentioning neural networks
  - deep learning        # Deep learning related research
  - transformers         # Transformer architecture papers
```

### Error Message Examples
```python
# Good error messages for non-technical users
"Configuration Error: Please check your email settings in the GitHub repository secrets. Make sure SENDER_EMAIL is set to a valid email address."

"API Error: Unable to fetch papers from arXiv. This might be a temporary issue. The system will retry automatically in 1 hour."

# Bad error messages
"HTTPError 500"
"Config missing"
```

This rules file ensures code quality while keeping the project accessible to non-technical users through clear documentation, simple configuration, and helpful error messages. 